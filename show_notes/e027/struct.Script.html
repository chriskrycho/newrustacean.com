<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="API documentation for the Rust `Script` struct in crate `show_notes`."><meta name="keywords" content="rust, rustlang, rust-lang, Script"><title>show_notes::e027::Script - Rust</title><link rel="stylesheet" type="text/css" href="../../normalize.css"><link rel="stylesheet" type="text/css" href="../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../../dark.css"><link rel="stylesheet" type="text/css" href="../../light.css" id="themeStyle"><script src="../../storage.js"></script><link rel="shortcut icon" href="http://newrustacean.com/favicon.ico"></head><body class="rustdoc struct"><!--[if lte IE 8]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu">&#9776;</div><a href='../../show_notes/index.html'><img src='http://newrustacean.com/podcast.png' alt='logo' width='100'></a><p class='location'>Struct Script</p><div class="sidebar-elems"><div class="block items"><a class="sidebar-title" href="#synthetic-implementations">Auto Trait Implementations</a><div class="sidebar-links"><a href="#impl-Send">Send</a><a href="#impl-Sync">Sync</a></div><a class="sidebar-title" href="#blanket-implementations">Blanket Implementations</a><div class="sidebar-links"><a href="#impl-From">From</a><a href="#impl-Into">Into</a><a href="#impl-TryFrom">TryFrom</a><a href="#impl-Borrow">Borrow</a><a href="#impl-TryInto">TryInto</a><a href="#impl-BorrowMut">BorrowMut</a><a href="#impl-Any">Any</a></div></div><p class='location'><a href='../index.html'>show_notes</a>::<wbr><a href='index.html'>e027</a></p><script>window.sidebarCurrent = {name: 'Script', ty: 'struct', relpath: ''};</script><script defer src="sidebar-items.js"></script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!"><img src="../../brush.svg" width="18" alt="Pick another theme!"></button><div id="theme-choices"></div></div><script src="../../theme.js"></script><nav class="sub"><form class="search-form js-only"><div class="search-container"><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‚ÄòS‚Äô to search, ‚Äò?‚Äô for more options‚Ä¶" type="search"><a id="settings-menu" href="../../settings.html"><img src="../../wheel.svg" width="18" alt="Change settings"></a></div></form></nav><section id="main" class="content"><h1 class='fqn'><span class='out-of-band'><span id='render-detail'><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class='inner'>&#x2212;</span>]</a></span><a class='srclink' href='../../src/show_notes/e027.rs.html#280' title='goto source code'>[src]</a></span><span class='in-band'>Struct <a href='../index.html'>show_notes</a>::<wbr><a href='index.html'>e027</a>::<wbr><a class="struct" href=''>Script</a></span></h1><div class="docblock type-decl hidden-by-usual-hider"><pre class='rust struct'>pub struct Script;</pre></div><div class='docblock'><h1 id="e027-i-promise-trust-me" class="section-header"><a href="#e027-i-promise-trust-me">e027: I Promise; Trust Me</a></h1>
<p>Hello, I‚Äôm Chris Krycho, and this is New Rustacean: a show about the Rust Programming Language and the people who use it. This is Episode 27: I Promise; Trust Me.</p>
<h2 id="sponsor-parity-technologies" class="section-header"><a href="#sponsor-parity-technologies">Sponsor: Parity Technologies</a></h2>
<p>Parity Technologies is here sponsoring another episode! Parity is advancing the state of the art in decentralized technology. Their flagship software is the Parity Ethereum client, but they're also building cutting-edge tech in areas like WebAssembly and peer-to-peer networking. Their next big project is Polkadot, a platform leveraging blockchain tech for scaling and interop in decentralized systems. Parity uses Rust for its trifecta of safety, speed, and correctness‚Äîand they‚Äôre still hiring Rust developers! Check out their jobs at paritytech.io/jobs.</p>
<p>Thanks again to Parity for sponsoring the show!</p>
<h2 id="what-is-safety" class="section-header"><a href="#what-is-safety">What is safety?</a></h2>
<p>One of the most interesting claims Rust makes is that it can help us write <em>safer</em> code. I call this interesting because there‚Äôs a lot bundled up in that word: ‚Äúsafe‚Äù. We‚Äôre digging in, this episode, to the idea of safety through the lens of Rust‚Äôs keyword <code>unsafe</code>. But if we want to understand what we‚Äôre saying with <code>unsafe</code>, we need to understand what Rust means by ‚Äúsafe‚Äù in the rest of the code. Code marked <code>unsafe</code> is unsafe by <em>contrast</em> with the rest of Rust.</p>
<p>So: what is safety?</p>
<p>Safety is a specific set of guarantees about specific kinds of undesired behavior around memory. It is <em>not</em> a guarantee that your program will never crash, or that you won‚Äôt have logic bugs, or that you won‚Äôt get into deadlocks. It is a claim about <em>memory access</em> and <em>threads</em>, not about logic! The list of things Rust protects us from (and here I‚Äôm quoting from the Nomicon, the official Rust guide to writing <code>unsafe</code> Rust):</p>
<blockquote>
<ul>
<li>Dereferencing null, dangling, or unaligned pointers</li>
<li>Reading uninitialized memory</li>
<li>Breaking the pointer aliasing rules</li>
<li>Producing invalid primitive values:</li>
<li>dangling/null references</li>
<li>null <code>fn</code> pointers</li>
<li>a <code>bool</code> that isn't 0 or 1</li>
<li>an undefined <code>enum</code> discriminant</li>
<li>a <code>char</code> outside the ranges <code>[0x0, 0xD7FF]</code> and <code>[0xE000, 0x10FFFF]</code></li>
<li>A non-utf8 <code>str</code></li>
<li>Unwinding into another language</li>
<li>Causing a data race</li>
</ul>
</blockquote>
<p>That‚Äôs not a short list‚Ä¶ but it‚Äôs not that long of a list, either! There are still plenty of things that can go wrong. For example: data races are prevented‚Ä¶ but you can still have race conditions in a more general sense: those races just can‚Äôt cause memory unsafety.</p>
<p>However, that list <em>does</em> eliminate a lot of the worst kinds of unsafety in the world of programming ‚Äì¬†and in particular, it eliminates the kinds of bugs that cause segmentation faults or corruption in the data of your program. This is what makes Rust such a big deal: those kinds of guarantees have only ever been available (in mainstream languages at least) in languages with managed memory. So safe Rust is pretty safe!</p>
<h2 id="unsafe" class="section-header"><a href="#unsafe"><code>unsafe</code></a></h2>
<p>So when we talk about ‚Äúunsafe‚Äù Rust, does that mean all the rules go out the window? Happily, <em>no</em></p>
<p>We‚Äôll dig into details around what it means to mark blocks, functions, or traits with the <code>unsafe</code> keyword in a minute. First, though, it‚Äôs important to understand that writing <code>unsafe</code> Rust does <em>not</em> mean you‚Äôre now in a free-for-all zone. If you‚Äôre <em>not</em> using one of the very specific additional abilities that <code>unsafe</code> unlocks, all of Rust‚Äôs other normal compiler rules and safety checking behaviors are still in play. You heard that right: the compiler checks you just as much inside an <code>unsafe</code> block as outside, other than some very specific abilities.</p>
<p>So, for example, if you‚Äôre using a normal Rust reference instead of a raw pointer, the borrow checker will still check your access, just like normal! I‚Äôve linked to <a href="https://play.rust-lang.org/?version=beta&amp;mode=release&amp;edition=2018&amp;gist=38d1089cdc3a4148609e9e3bbbfd002c">a Rust playground example</a> in the show notes so you can see exactly this (along with a warning that the <code>unsafe</code> block in the example is unnecessary).</p>
<p>The takeaway here, before we dig into what each of those special <code>unsafe</code> abilities gains us, is that they don‚Äôt remove Rust‚Äôs normal safety checks in a general sense ‚Äì they just let you do these specific <em>additional</em> (unsafe) things. As the Nomicon (the official Rust guide to <code>unsafe</code> Rust) <a href="https://doc.rust-lang.org/nomicon/safe-unsafe-meaning.html">puts it</a>:</p>
<blockquote>
<p>The unsafe keyword has two uses: to declare the existence of contracts the compiler can't check, and to declare that a programmer has checked that these contracts have been upheld.</p>
</blockquote>
<p>One other thing to notice: just because we‚Äôre writing code in an <code>unsafe</code> block does <em>not</em> mean that what we‚Äôre doing is actually not a safe thing to do. In fact, the <em>point</em> is the opposite! We intend to write <em>safe</em> code in <code>unsafe</code> blocks. The difference is whether the compiler can know they‚Äôre safe or not. For this reason, people have suggested‚Äîwith various degrees of seriousness, and none of them serious enough to write an RFC‚Äîthat <code>unsafe</code> should have a different name: something like <code>vouchsafe</code> or <code>trustme</code>. Because code in an <code>unsafe</code> block is code where the normal trust paradigm with Rust is inverted: instead of <em>my</em> trusting the compiler to keep the code from ending up in conditions that would, say, segfault, the compiler has to trust <em>me</em> to keep the code from ending up in those conditions.</p>
<p>So: what are the special abilities unlocked by the <code>unsafe</code> keyword? Just these (<a href="https://doc.rust-lang.org/book/second-edition/ch19-01-unsafe-rust.html">quoting from</a> the most official source: <cite>The Rust Programming Language</cite> book):</p>
<blockquote>
<ul>
<li>Dereference a raw pointer</li>
<li>Call an unsafe function or method</li>
<li>Access or modify a mutable static variable</li>
<li>Implement an unsafe trait</li>
</ul>
</blockquote>
<p>We‚Äôll talk about each of those in turn.</p>
<h3 id="dereferencing-raw-pointers" class="section-header"><a href="#dereferencing-raw-pointers">Dereferencing raw pointers</a></h3>
<p>The first thing you can do with <code>unsafe</code> is dereference a raw pointer. Let‚Äôs start by talking a little about the difference between a raw pointer and a normal ‚Äúreference‚Äù in Rust, since ‚Äúpointers‚Äù and ‚Äúreferences‚Äù often get conflated in imprecise discussions. The difference between pointers and references is less one of <em>mechanics</em> and more one of <em>semantics</em>: what they mean and therefore what the compiler will let you do with them.</p>
<p>Under the hood, both a raw pointer and a reference contain a memory address. However, semantically speaking, the <em>value</em> of a pointer is that memory address, while the <em>value</em> of a reference is the thing it‚Äôs pointing to.</p>
<p>When you interact with a reference in Rust, you‚Äôre never concerned with the specific memory address involved: it is <em>only</em> a way of getting access to some item where it already exists, rather than having to copy all of its data around over and over.</p>
<p>When you interact with a pointer in Rust, you are interacting with a specific <code>isize</code> value, which contains a memory location. It‚Äôs an <code>isize</code> because <code>isize</code> is the name of the type which is large enough to hold a memory address on the architecture you‚Äôre running on ‚Äì so for a 32-bit architecture, <code>isize</code> is 4 bytes, and for a 64-bit architecture, it‚Äôs 8 bytes. If you somehow managed to get Rust running on an 8-bit architecture, it‚Äôd be 1 byte! But the point here is that the pointer is not just an indirection to get at some piece of data somewhere in memory: it is the address itself.</p>
<p>That difference goes right down through the division between safe and unsafe Rust. Pointers and references are still pointers and references. And pointers are things you can do things with in safe Rust! You can get pointer values in safe Rust, e.g. with <code>Box::into_raw</code>. You can even mutate them, so that they point at something else, in safe Rust. (There‚Äôs an example in the show notes, as well as <a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2015&amp;gist=3a7a9facd0f67d4a590afc3a3ecef95b">a link to a Rust playground</a> showing exactly this.) The huge thing you cannot do in safe Rust is dereference a raw pointer. That is: you cannot go ‚Äúthrough‚Äù the pointer to get at the data at that memory location. In unsafe Rust, you can.</p>
<p>The reason for this is simple: let‚Äôs say I get a pointer by calling <code>Box::into_raw</code> with a valid <code>Box&lt;SomeStruct&gt;</code>. That pointer is valid. But  now, as I noted a second ago, I can change it. I could, say, just put the hex value <code>0x10</code> in it. And behind the address <code>0x10</code> is‚Ä¶ who knows what? It could be uninitialized. It could be empty. It could be a different piece of data ‚Äì¬†maybe one being used by another thread! And when I call <code>Box::into_raw</code>, I get back a <em>mutable</em> pointer, so if I could dereference it, I could mess with the values on the other side of it. All of which means that I can create just about any kind of mess you can imagine if I‚Äôm allowed to dereference a raw pointer!</p>
<p>Many of the data structure implementations in the standard library use <code>unsafe</code> heavily to do things that can be <em>verified</em> but are not doable with safe code. For example: the implementation of <code>Clone</code> for <code>Box</code> is <code>unsafe</code>, because it does a direct memory copy from one pointer location to another, and <em>that</em> is <code>unsafe</code> because the caller has to make sure that the source and destination locations (a) are both legitimate to access and (b) don‚Äôt overlap!</p>
<h3 id="calling-unsafe-functions-or-methods" class="section-header"><a href="#calling-unsafe-functions-or-methods">Calling <code>unsafe</code> functions or methods</a></h3>
<p>So that covers raw pointers. What about <code>unsafe</code> functions and methods? The obvious reason we might need unsafe at the level of a function or a method is that the function cannot guarantee the safety of a given operation with just the information it needs to <em>execute</em>. That is: the function or method has guarantees <em>you</em> need to uphold ‚Äì¬†guarantees that should hopefully be very well-documented.</p>
<p>A prime example of this is any kind of FFI interaction! If you‚Äôre dealing with memory from outside Rust ‚Äì say, because you‚Äôre calling out to C, or because you‚Äôre using Rust to speed up an Elixir computation, or so on ‚Äì by definition the compiler can‚Äôt check that you‚Äôre keeping things straight. It doesn‚Äôt know about everything going on in the other language! So calling a function that is in another language is inherently unsafe!</p>
<h3 id="interacting-with-mutable-static-bindings" class="section-header"><a href="#interacting-with-mutable-static-bindings">Interacting with mutable <code>static</code> bindings</a></h3>
<p>Okay, now let‚Äôs talk about mutable <code>static</code> variables. <code>static</code>s are <em>global</em> items in Rust, and in safe Rust, they can‚Äôt be changed, because as a lot of people have said over the years, ‚ÄúShared mutable state is the root of all evil‚Äù and mutable global variables are the definition of shared mutable state. A <code>static</code> variable in Rust has a specific, unchanging location in memory, and you can of course have references to <code>static</code> values in normal Rust. In fact, you <em>often</em> do: that‚Äôs what any static string is, for example! So if you could <em>change</em> them‚Ä¶ you could have data races if multiple threads had references to that particular <code>static</code> at the same time and tried to read or write to it. Bad times would ensue.</p>
<p>There are times when having a single piece of global, mutable state is useful, rare though they may be. But, as usual, we need to very carefully constrain how that is handled so we don‚Äôt shoot ourselves in the foot. Thus, we can only change <em>or</em> read mutable <code>static</code> variables in <code>unsafe</code> blocks.</p>
<h3 id="implementing-unsafe-traits" class="section-header"><a href="#implementing-unsafe-traits">Implementing <code>unsafe</code> traits</a></h3>
<p><b>Note to readers:</b> this section is incorrect; see the comments <a href="/show_notes/e027/index.html#errata">in the show notes</a>.</p>
<p>Finally, we have <code>unsafe</code> traits. These are basically just one abstraction layer up from the things I just covered with <code>unsafe</code> functions and methods and with raw pointers. If a trait has a <em>method</em> which is <code>unsafe</code>, then the trait itself also has to be <code>unsafe</code>. The prime examples for <code>unsafe</code> traits are <code>Send</code> and <code>Sync</code>, which I covered back in episode 22. If you build a custom type that uses raw pointers, the Rust compiler by definition can‚Äôt tell if you‚Äôre using it in a way that is safe to share across threads (either as a value or a reference), so you have to write the <code>Send</code> and <code>Sync</code> implementations yourself‚Ä¶ and that is unsafe, just as you would expect.</p>
<h2 id="safe-abstractions" class="section-header"><a href="#safe-abstractions">Safe abstractions</a></h2>
<p>So those are the four things Rust lets us do with <code>unsafe</code>. But there‚Äôs more to say here, because the <em>most important thing</em> about <code>unsafe</code> in Rust is that you can constrain the unsafety. It isn‚Äôt a virus that infects everything it touches. You can (and basically always do!) wrap <code>unsafe</code> code with code that <em>is</em> safe. In fact, this is how large swaths of the Rust standard library are implemented. This ability to provide a safe abstraction around an unsafe implementation is at the core of what makes Rust viable.</p>
<p>As we just talked about, there are things you <em>cannot</em> do in safe Rust code, but which you <em>have</em> to be able to do to get the kinds of performance we‚Äôre looking for. The trick is making it so that the other people using your code aren‚Äôt exposed to those unsafe things. This is of course not specific to Rust! Well-written C and C++ does the same kind of thing, and of course this same basic idea is fundamental to the notion of abstraction in programming.</p>
<p>The difference with Rust as compared to C or C++ is that we have a tool for making the boundaries between the unsafe and the safe code explicit. Code inside an <code>unsafe</code> block is allowed to make those four moves we discussed, with all their ramifications. Code outside an <code>unsafe</code> block‚Ä¶ isn‚Äôt. So when you write a chunk of <code>unsafe</code> code, you‚Äôre responsible to uphold the invariants required to make the safe wrapper, well, <em>safe</em>.</p>
<p>Here‚Äôs an analogy. One of the fundamental data structures we use all the time is a stack, where the first thing in is the last thing out. From the perspective of someone using a stack, the only thing we care about is that we have the tools we need to put more items into the stack or to get items back out of the stack.</p>
<p>However, there are lots of ways you can <em>implement</em> a stack while keeping those constraints for users. You could use a simple linked list. In Rust we could just have something like <code>Option&lt;Box&lt;Node&gt;&gt;</code>, where the <code>Box&lt;Node&gt;</code> is our dynamic pointer to the next item. Every item in the stack would have <code>Some(Box&lt;Node&gt;)</code>, except the first one, which would have <code>None</code>. Or we could use a <code>Vec</code> and keep track of the latest item with an index pointing to the most recently inserted location in the vector.</p>
<p>From the perspective of someone <em>using</em> the list, none of those details matter. We can choose the underlying data structure that gives us the best performance tradeoffs for our particular stack‚Äôs needs.</p>
<p>However, we have to make sure that the functions we supply for interacting with our stack do what we say that they do! In the list-based variant, we need to make sure that we only ever append to the end of the list. Otherwise we‚Äôll end up with a tree! (Happily, Rust would actually stop us here unless we switched from <code>Box</code> to something like <code>Rc</code>, because otherwise there would be two owning pointers.) Likewise, in the <code>Vec</code>-based version, we would need to be careful to set the index correctly when adding or removing items from the end of the <code>Vec</code>. We are responsible for upholding the invariants for our abstract data structure with the concrete implementations.</p>
<p>This is exactly the same thing going on with <code>unsafe</code>. The abstraction around the unsafe code and the unsafe block itself are responsible to ensure that the function <em>does the right thing</em> with the data outside callers hand it. But now we‚Äôve isolated it, at the programming language level, and we can know with confidence exactly where any bugs in the behavior of that unsafe abstraction come from. Or, to put a more positive spin on it, we can know where we need to focus our design and testing and verification efforts!</p>
<p>I really liked how Nerijus Arlauskas put it in a blog post (which I have of course linked in the show notes), <a href="http://nercury.github.io/rust/opengl/tutorial/2018/02/08/opengl-in-rust-from-scratch-00-setup.html">Rust and OpenGL from Scratch</a>:</p>
<blockquote>
<p>It may seem strange that ‚Äúunsafe‚Äù exists at all. The reason for it is quite simple: it allows us to deal with complicated stuff once, inside a function with a safe API, and then completely forget about it when we become the users of that API. In other words, it moves the responsibility of correct API usage to API implementer.</p>
</blockquote>
<p>One last note here: in some languages, the default is that all items in a given module are public, and you have to go out of your way to hide them. That‚Äôs not the case in Rust ‚Äì and it‚Äôs absolutely essential that it not be the case in Rust! We can (and indeed basically <em>must</em>) use privacy to make it so that we can uphold the invariants we need in a given context. Have a function you need that isn‚Äôt itself <code>unsafe</code> but which can break invariants that <code>unsafe</code> code needs upheld to make sure it works correctly? Leave it private to the module and write good comments explaining exactly how it has to be used to uphold those invariants: then the only possible places where things could go amiss are, again, scoped!</p>
<h2 id="closing" class="section-header"><a href="#closing">Closing</a></h2>
<p>Thanks to everyone who sponsors the show! This month‚Äôs $10-or-more sponsors included:</p>
<ul>
<li>James Hagans II</li>
<li>Paul Naranja</li>
<li>Ryan Osial</li>
<li>Chip</li>
<li>Bryce Johnston</li>
<li>Dan Abrams</li>
<li>Alexander Payne</li>
<li>Bryan Stitt</li>
<li>Ramon Buckland</li>
<li>Jako Danar</li>
<li>Nathan Sculli</li>
<li>Scott Moeller</li>
<li>John Rudnick</li>
<li>Steffen Loan Sunde</li>
<li>Matt Rudder</li>
<li>Raph Levien</li>
<li>Michael Mc Donnell</li>
<li>Chris Palmer</li>
<li>Oluseyi Sonaiya</li>
<li>Daniel Collin</li>
<li>Joseph Marhee</li>
<li>Brian McCallister</li>
<li>Nick Gideo</li>
<li>Graham Wihlidal</li>
<li>Nicolas Pochet</li>
<li>Behnam Esfahbod</li>
<li>Jonathan Knapp</li>
<li>Nick Stevens</li>
<li>Jerome Froelick</li>
<li>Rob Tsuk</li>
<li>Daniel Mason</li>
<li>Adam Green</li>
<li>Anthony Deschamps</li>
<li>Peter Tillemans</li>
<li>Martin Heuschober</li>
</ul>
<p>If you‚Äôd like to sponsor the show, you set up ongoing support at patreon.com/newrustacean, or send a one-off at any of a number of other services listed at newrustacean.com. The website also has scripts and code samples for most of the teaching episodes as well as transcripts for many of the interviews, along with full show notes for every episode. You can find the notes for _this_ episode at &lt;newrustacean.com/show_notes/e025/&gt;.</p>
<p>If you're enjoying New Rustacean, please help others find it ‚Äì by telling them about it in person, by sharing it on social media, or by rating and reviewing the show in your favorite podcast directory.</p>
<p>The show is on Twitter @newrustacean, or you can follow me there @chriskrycho. Tweet me with news, topic ideas, etc! You can also respond in the threads on the Rust user forums, Reddit, or Hacker News, or‚Äîand this will always be my favorite‚Äîjust send me an email at hello@newrustacean.com.</p>
<p>Until next time, happy (maybe unsafe!) coding!</p>
</div><h2 id='synthetic-implementations' class='small-section-header'>Auto Trait Implementations<a href='#synthetic-implementations' class='anchor'></a></h2><div id='synthetic-implementations-list'><h3 id='impl-Send' class='impl'><span class='in-band'><table class='table-display'><tbody><tr><td><code>impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> for <a class="struct" href="../../show_notes/e027/struct.Script.html" title="struct show_notes::e027::Script">Script</a></code><a href='#impl-Send' class='anchor'></a></span></td><td><span class='out-of-band'></span></td></tr></tbody></table></h3><div class='impl-items'></div><h3 id='impl-Sync' class='impl'><span class='in-band'><table class='table-display'><tbody><tr><td><code>impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> for <a class="struct" href="../../show_notes/e027/struct.Script.html" title="struct show_notes::e027::Script">Script</a></code><a href='#impl-Sync' class='anchor'></a></span></td><td><span class='out-of-band'></span></td></tr></tbody></table></h3><div class='impl-items'></div></div><h2 id='blanket-implementations' class='small-section-header'>Blanket Implementations<a href='#blanket-implementations' class='anchor'></a></h2><div id='blanket-implementations-list'><h3 id='impl-From' class='impl'><span class='in-band'><table class='table-display'><tbody><tr><td><code>impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a> for T</code><a href='#impl-From' class='anchor'></a></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/convert.rs.html#461-463' title='goto source code'>[src]</a></span></td></tr></tbody></table></h3><div class='impl-items'><h4 id='method.from' class="method hidden"><span id='from.v' class='invisible'><table class='table-display'><tbody><tr><td><code>fn <a href='https://doc.rust-lang.org/nightly/core/convert/trait.From.html#tymethod.from' class='fnname'>from</a>(t: T) -&gt; T</code></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/convert.rs.html#462' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock hidden'><p>Performs the conversion.</p>
</div></div><h3 id='impl-Into' class='impl'><span class='in-band'><table class='table-display'><tbody><tr><td><code>impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a> for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt;,&nbsp;</span></code><a href='#impl-Into' class='anchor'></a></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/convert.rs.html#452-457' title='goto source code'>[src]</a></span></td></tr></tbody></table></h3><div class='impl-items'><h4 id='method.into' class="method hidden"><span id='into.v' class='invisible'><table class='table-display'><tbody><tr><td><code>fn <a href='https://doc.rust-lang.org/nightly/core/convert/trait.Into.html#tymethod.into' class='fnname'>into</a>(self) -&gt; U</code></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/convert.rs.html#454-456' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock hidden'><p>Performs the conversion.</p>
</div></div><h3 id='impl-TryFrom' class='impl'><span class='in-band'><table class='table-display'><tbody><tr><td><code>impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a> for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;U&gt;,&nbsp;</span></code><a href='#impl-TryFrom' class='anchor'></a></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/convert.rs.html#480-486' title='goto source code'>[src]</a></span></td></tr></tbody></table></h3><div class='impl-items'><h4 id='associatedtype.Error' class="type"><span id='Error.t' class='invisible'><code>type <a href='https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error' class="type">Error</a> = <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.never.html">!</a></code></span></h4>
<div class='stability'><div class='stab unstable'><span class=microscope>üî¨</span> This is a nightly-only experimental API.  (<code>try_from</code>)</div></div><div class='docblock'><p>The type returned in the event of a conversion error.</p>
</div><h4 id='method.try_from' class="method hidden"><span id='try_from.v' class='invisible'><table class='table-display'><tbody><tr><td><code>fn <a href='https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#tymethod.try_from' class='fnname'>try_from</a>(value: U) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;T, &lt;T as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt;&gt;::<a class="type" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</code></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/convert.rs.html#483-485' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='stability hidden'><div class='stab unstable'><span class=microscope>üî¨</span> This is a nightly-only experimental API.  (<code>try_from</code>)</div></div><div class='docblock hidden'><p>Performs the conversion.</p>
</div></div><h3 id='impl-Borrow' class='impl'><span class='in-band'><table class='table-display'><tbody><tr><td><code>impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a> for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></code><a href='#impl-Borrow' class='anchor'></a></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#219-221' title='goto source code'>[src]</a></span></td></tr></tbody></table></h3><div class='impl-items'><h4 id='method.borrow' class="method hidden"><span id='borrow.v' class='invisible'><table class='table-display'><tbody><tr><td><code>fn <a href='https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html#tymethod.borrow' class='fnname'>borrow</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;</a>T</code></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#220' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock hidden'><p>Immutably borrows from an owned value. <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html#tymethod.borrow">Read more</a></p>
</div></div><h3 id='impl-TryInto' class='impl'><span class='in-band'><table class='table-display'><tbody><tr><td><code>impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html" title="trait core::convert::TryInto">TryInto</a> for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;,&nbsp;</span></code><a href='#impl-TryInto' class='anchor'></a></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/convert.rs.html#468-475' title='goto source code'>[src]</a></span></td></tr></tbody></table></h3><div class='impl-items'><h4 id='associatedtype.Error-1' class="type"><span id='Error.t-1' class='invisible'><code>type <a href='https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html#associatedtype.Error' class="type">Error</a> = &lt;U as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="type" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a></code></span></h4>
<div class='stability'><div class='stab unstable'><span class=microscope>üî¨</span> This is a nightly-only experimental API.  (<code>try_from</code>)</div></div><div class='docblock'><p>The type returned in the event of a conversion error.</p>
</div><h4 id='method.try_into' class="method hidden"><span id='try_into.v' class='invisible'><table class='table-display'><tbody><tr><td><code>fn <a href='https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html#tymethod.try_into' class='fnname'>try_into</a>(self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;U, &lt;U as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="type" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</code></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/convert.rs.html#472-474' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='stability hidden'><div class='stab unstable'><span class=microscope>üî¨</span> This is a nightly-only experimental API.  (<code>try_from</code>)</div></div><div class='docblock hidden'><p>Performs the conversion.</p>
</div></div><h3 id='impl-BorrowMut' class='impl'><span class='in-band'><table class='table-display'><tbody><tr><td><code>impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a> for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></code><a href='#impl-BorrowMut' class='anchor'></a></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#224-226' title='goto source code'>[src]</a></span></td></tr></tbody></table></h3><div class='impl-items'><h4 id='method.borrow_mut' class="method hidden"><span id='borrow_mut.v' class='invisible'><table class='table-display'><tbody><tr><td><code>fn <a href='https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut' class='fnname'>borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut </a>T</code></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#225' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock hidden'><p>Mutably borrows from an owned value. <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></p>
</div></div><h3 id='impl-Any' class='impl'><span class='in-band'><table class='table-display'><tbody><tr><td><code>impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html" title="trait core::any::Any">Any</a> for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'static + ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></code><a href='#impl-Any' class='anchor'></a></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/any.rs.html#114-116' title='goto source code'>[src]</a></span></td></tr></tbody></table></h3><div class='impl-items'><h4 id='method.get_type_id' class="method hidden"><span id='get_type_id.v' class='invisible'><table class='table-display'><tbody><tr><td><code>fn <a href='https://doc.rust-lang.org/nightly/core/any/trait.Any.html#tymethod.get_type_id' class='fnname'>get_type_id</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/core/any/struct.TypeId.html" title="struct core::any::TypeId">TypeId</a></code></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/any.rs.html#115' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='stability hidden'><div class='stab unstable'><details><summary><span class=microscope>üî¨</span> This is a nightly-only experimental API.  (<code>get_type_id</code>)</summary><p>this method will likely be replaced by an associated static</p>
</details></div></div><div class='docblock hidden'><p>Gets the <code>TypeId</code> of <code>self</code>. <a href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html#tymethod.get_type_id">Read more</a></p>
</div></div></div></section><section id="search" class="content hidden"></section><section class="footer"></section><aside id="help" class="hidden"><div><h1 class="hidden">Help</h1><div class="shortcuts"><h2>Keyboard Shortcuts</h2><dl><dt><kbd>?</kbd></dt><dd>Show this help dialog</dd><dt><kbd>S</kbd></dt><dd>Focus the search field</dd><dt><kbd>‚Üë</kbd></dt><dd>Move up in search results</dd><dt><kbd>‚Üì</kbd></dt><dd>Move down in search results</dd><dt><kbd>‚Üπ</kbd></dt><dd>Switch tab</dd><dt><kbd>&#9166;</kbd></dt><dd>Go to active search result</dd><dt><kbd>+</kbd></dt><dd>Expand all sections</dd><dt><kbd>-</kbd></dt><dd>Collapse all sections</dd></dl></div><div class="infos"><h2>Search Tricks</h2><p>Prefix searches with a type followed by a colon (e.g. <code>fn:</code>) to restrict the search to a given type.</p><p>Accepted types are: <code>fn</code>, <code>mod</code>, <code>struct</code>, <code>enum</code>, <code>trait</code>, <code>type</code>, <code>macro</code>, and <code>const</code>.</p><p>Search functions by type signature (e.g. <code>vec -> usize</code> or <code>* -> vec</code>)</p><p>Search multiple things at once by splitting your query with comma (e.g. <code>str,u8</code> or <code>String,struct:Vec,test</code>)</p></div></div></aside><link rel="stylesheet" href="/media-playback.css">
<script type="text/javascript" src="/media-playback.js" defer></script>


<script>window.rootPath = "../../";window.currentCrate = "show_notes";</script><script src="../../aliases.js"></script><script src="../../main.js"></script><script defer src="../../search-index.js"></script></body></html>