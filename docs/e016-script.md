# `RefCell`s and code smells

## Intro

Hello, I'm Chris Krycho, and this is the New Rustacean podcast---a 15--20 minute show about learning the Rust programming language. This is *Episode 16: `RefCell`s and code smells.*

## News and Follow-Up

- The first community survey came out on June 30 (after I recorded with Raph Levien, but before I released the second half of the interview). I'll link the blog post in the show notes---there's a lot of really interesting stuff in there.
- Rust 1.10 came out on July 7. The big highlight features from it were:
    + stable support for defining what should happen when a `panic!` occurs in your code: do you unwind nicely, or just abort immediately? Previously, Rust always unwound nicely; now you can tell it to abort instead---a nice improvement for people writing things like operating systems, but also, depending on what you're doing, it might just be nice overall, as it gives you roughly 10% faster compilation and roughly 10% smaller binaries.
    + the compiler got less memory hungry *and* faster. Hooray!
    + the compiler now knows how to generate a new kind of dynamic library---one much better suited for embedding Rust in other contexts, like using it as a library for some piece of functionality in another application.
    + this was the first release of Rust which is able to be built using *stable* Rust---you no longer have to use a nightly version of the language to build the language itself. So Rust 1.10 was built with Rust 1.9, and the upcoming Rust 1.11 will be built with Rust 1.10, and so on.
- rustup 0.3.0 came out July 14th. It fixed a bunch of bugs, improved the user interface in some small ways, and laid the foundation for using `rustls`, a TLS library written in Rust (and therefore hopefully safer and more reliable than the existing, C-based TLS implementations out there)!
- the JetBrains Rust IDE, currently just called IntelliJ Rust, got a website: intellij-rust.github.io. Check it out! More importantly, if you use any JetBrains IDE, you can and should install the plugin and play with it---it's coming along *very* nicely.
- Carol Nichols and Jake Goulding launched Integer32, a Rust-focused consultancy. To my knowledge (which is admittedly *very* incomplete!), it's the first of its kind. I suspect it won't be the last, since the number of tech companies publicly discussing their Rust usage is going up all the time.
- Finally, there's a really interesting-looking talk on a tool called Tango that lets you do "literate programming" in Rust---i.e. you write in Markdown and then insert GitHub-style code snippets of Rust, and it's compilable as actual Rust. I'll probably be doing some of this going forward! I'll link both the talk and the source.

## `Cell` and `RefCell`

In the last normal episode, we talked about smart pointers---the more ordinary ones like `Box` or `Vec`, and the reference counting ones like `Rc` and `Arc`. We also briefly mentioned when you'd want to use those, and then in a happy turn of events, those same topics came up quite a bit in my interview with Raph Levien. I was already planning to come back to this topic, but the interview made it even more appropriate, and I had several listeners request it explicitly, so today we're going to talk about *using* the smart pointer types, with a bit more detail than we covered last time. Specifically, we're going to talk about two things:

1. dealing with the `Cell` and `RefCell` types with immutable containers which have mutable contents
2. using the `Borrow` and `AsRef` traits to make it easier to deal with related data types in API design

One thing to keep in mind: although it's important to know how these things work, it adds a *lot* of complexity. If you can simply avoid having to deal with smart pointers in a given instance, and let the Rust compiler just help you out with normal ownership and borrowing semantics, *do that instead*. You will be glad you did. There are definitely times when you need to opt into the more complex things you can do with these smart pointer types, but don't default to them. Treat them like a "code smell"---the idea of something that isn't necessarily *bad* in and of itself, but which can be a signal that something is wrong if you see too much of it. If you smell a *little* bit of fish, it's fine (and it might even be good). If you smell a *lot* of fish, it's nasty. The same thing goes for "code smells": using a `Box` here or an `Arc` there is fine, and even *good* sometimes. But if they're everywhere, there's probably a better, more Rustic way to approach the problem---one that will perform better, give you easier errors to diagnose at compile time instead of run time, and hopefully be easier to write and maintain, as a result.

### Exterior Immutability and Interior Mutability (`Cell` and `RefCell`)

Now, into the meat of the episode. We talked in e015 about how you can use `Rc` and `Arc` to handle shared data within a thread and between threads respectively. We talked about how to deal with the case that you need to get at the data within them using the `get_mut` method if there is only one strong reference and no weak references to the data.

All of that was well and good, but it left us with a real problem---one which might not have been especially apparent to you, but which will become increasingly annoying if you spend any significant amount of time working with the `Rc` or `Arc` types: *what if you need the data to---at least potentially---be mutable from multiple places at runtime*?

Let's say you're building some data structure which multiple threads need to be able to access, and where you can't know at compile time whether the reference count will be zero. Say, further, that you've declared the wrapping smart pointer as immutable, because you want to make sure that no one is changing it willy-nilly. How would you do that?

And in fact, this issue can come up with smart pointer types in general. Imagine you had a `Vec` wrapping some other `struct` type you'd defined---and you wanted the `Vec` to be immutable, so that different clients could read the contents of the `Vec` but not modify it, but you *also* wanted the `struct` instances *within* the `Vec` to be mutable. We literally cannot do that by default: if the `Vec` instance is immutable, so is everything it contains. (You can take a look at the show notes for the episode to see this in practice. There's a commented-out line there which simply won't compile if you uncomment it, for precisely this reason.) So whether we're dealing with simple vectors of data, or sharing data between threads, there are times when we might want an *immutable container* containing *mutable data*.

This is where `Cell` and `RefCell` come in. We could wrap that custom struct inside a `Cell` or `RefCell`, and then if we wanted to, say, iterate over the items of the `Vector` and updating the contents of each `struct` we had defined within it, we could do that. With either `Cell` or `RefCell`, we would just wrap each item in the corresponding `new()` function when adding it to the vector. So if we had a vector named `my_list_of_things`, and a struct named `Thing` with a bog-standard `new()` method (clever, I know), we would type `my_list_of_things.push(Cell::new(Thing::new()))` when we added it to the vector. The *type* of the vector would then be `Vec<Cell<Thing>>`. That is, it's a *vector* wrapping a *cell* wrapping a *thing*. As you can see, we've dialed up the complexity a fair bit in order to be able to get this flexibility at runtime.

The difference between `Cell` and `RefCell` is whether we're dealing with data that can be copied simply or not. More specifically, we can use the `Cell` type to wrap up any type which implements the `Copy` trait, which defines how to do a straightforward copy of the underlying data. One easy way to think of it is: anything you could trivially `memcpy` in C, you can implement `Copy` for in Rust. In general, value types can always implement `Copy`, but reference types may not be able to---`String`, for example, doesn't, because it uses `Vec`, and `Vec` doesn't implement `Copy` (and I don't think it *can*, because its size can change dynamically).

This also means that using `Cell` doesn't have any cost at run-time: it's not doing anything special, because it only wraps stack-allocated, value data, so it gives you a way to say, "Hey, these things here can be mutated freely" and the compiler can know that it's still safe. You might write a bug around this if you incorrectly assumed the data was immutable, but it would be a *logic* issue, not a *memory safety* issue.

So how do you *use* a `Cell`? Well, after you've wrapped something up in it, you can just use the `get()` and `set()` methods to read or write the value respectively. So in our `Vec<Cell<Thing>>` example, if `Thing` were just a type alias for an integer, we could double it by doing a for loop over the vector. Each step through the iterator would give us a `Cell<Thing>`; we would then use the `get()` method to get the old value and the `set()` method to set the new value, and when we're done, we'll have updated the value inside each `Thing` in the `Vec`, all while only having a standard, immutable reference to the `Vec` itself. And we won't have incurred any runtime costs; we'll just have let the compiler know, by using the `Cell`, that it is safe to mutate these particular fields even though you can't satisfy the borrow checker directly. Neat!

Now, by contrast with the `Cell` type, `RefCell` *does* have a run-time cost, because it does *run-time checking* that what you're doing is safe. The Rust book describes it as being like a single-threaded mutex---that is, a data structure which requires you to *lock* it before you write to it, as a way of signaling to anyone else trying to read from or write to it that it isn't safe, and then *unlock* it when you're done so that others can access it again. In other words, it's kind of like it's doing borrow checking *at runtime*, for situations where you can't do it at compile time. Any type which can't implement `Copy` but needs the interior mutability we discussed is a candidate for this, but you have to think carefully about that tradeoff.

The other big downside is that because we defer some of the error checking to runtime, you can end up with a `panic!` instead of a compile error. When you need it, you need it, though, and the upside is that you're still getting good guarantees about the behavior---far better to get a `panic!` and a graceful shutdown of the program with a nice stack trace than to have it explode somewhere apparently unrelated because you mismanaged the memory. Not, of course, that I've had that happen to me on a regular basis in legacy C and C++ code I came on to maintain.

Using `RefCell` is fairly similar to using a `Cell`, but instead of using the `get()` or `set()` functions, we use the `borrow()` and `borrow_mut()` functions. If we just need to *read* the data, we'll call `borrow()`, and if we need to *write* the data, we'll call `borrow_mut()`. As those names make clear, we really are doing borrow-checking at run-time! If we `borrow()` somewhere in our code, we can `borrow()` other places as well: just as with compile-time borrow checking, it's perfectly safe for lots of different parts of our code to *read* memory at the same time. However, if any part of our code has run `borrow_mut()`, it is *not* allowed for other parts of our code to try to use either `borrow()` or `borrow_mut()`, for the same reason you're only allowed to have one mutable reference and zero other references in normal, compile time borrow checking in Rust. If you *do* try to call `borrow()` or `borrow_mut()` on some piece of data which already had a mutable borrow out, you'll get a `panic!`.

One upshot of all of this is that if you have a type wrapped in `Cell` or `RefCell`, you only need *a reference* to some data---not a *mutable reference to it*, not a *unique* reference to it, like we usually would---to satisfy the borrow checker.

So how *do* you know when to use `Cell` or `RefCell`? Well, again: default to *not* using them. If you can just use normal references and borrowing and let the compiler strictly check all of it at runtime, do that. Then, if you *can't*, or if it becomes especially difficult, evaluate these two options. Do you reuse a given piece of data all over the place (so keeping track of borrows is hard, even impossible), but you only mutate it relatively rarely? It might be a good candidate for wrapping it up in a `Cell` or `RefCell`. If it implements `Copy`, stick to `Cell`. As part of that, if you have a large data structure you're dealing with, see if you can just wrap *part* of a type with `Cell` rather than the whole thing, so you don't incur the cost of copying a large struct around. If you have a type that can't implement `Copy`, and so can't just replace the data "for free" at runtime, then look at `RefCell`. You'll still get good guarantees about how it behaves, the performance penalty is pretty small, and if or when something *does* go wrong, you'll usually have a pretty good idea where and why from the `panic!` message.


## Outro -- Sponsors & Following

Next time, we'll follow up with a discussion of the `Borrow` and `AsRef` traits, and then put together `Borrow` and the `Copy` trait we touched on today to talk about the `Cow` type. Hint: it's not a large mammal!

On a personal note---thanks to everyone who has listened to the show. Between new episodes and the back catalog, New Rustacean had over 11,000 downloads in June, and has already had over 8,000 by mid-July. When episode 0 came out back in September, I had 76 downloads the whole month. That jump amazes me, and inspires me to keep at it---the Rust community is pretty fantastic. So thank you all for listening!

Another thing which inspires me in the sponsors, whose generosity is a huge part of making it possible for me to keep making the show. So thanks, as always, to Chris Palmer, Daniel Collin, Raph Levien, and Vesa Khailavirta for sponsoring the show this month! You can see a full list of sponsors in the show notes, and the top tier of sponsors on a dedicated page on the website as well.

If you're interested in sponsoring the show, you can set up recurring contributions at Patreon.com/newrustacean, or one-off contributions at a variety of other services listed at newrustacean.com.

There you will also find links to the news items from the top of the show, and some examples of using smart pointers *ergonomically* as we discussed today. You can also follow the show on Twitter \@newrustacean, or follow me there \@chriskrycho. You can help *others* find the show by rating and reviewing it on iTunes, recommending it in another podcast directory, tweeting about it, or just telling a friend!

So do respond on social media, in the threads for the episode on the Rust user forum or on Reddit, or via email at hello@newrustacean.com.

Until next time, happy coding!
